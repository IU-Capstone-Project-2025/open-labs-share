name: Deploy to Production

on:
  push:
    branches:
      - "*" # TODO: Change to main after testing

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Make gradlew executable
        run: find . -type f -name "gradlew" | xargs chmod +x

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Test api-gateway
        working-directory: ./services/api-gateway
        run: ./gradlew test

      - name: Test auth-service
        working-directory: ./services/auth-service
        run: ./gradlew test

      - name: Test users-service
        working-directory: ./services/users-service
        run: ./gradlew test
      
      # - name: Set up Go
      #   uses: actions/setup-go@v5
      #   with:
      #     go-version: '1.20'

      # - name: Test feedback-service
      #   working-directory: ./services/feedback-service
      #   run: go test ./...

      # - name: Set up Node.js
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: '20'

      # - name: Test frontend
      #   working-directory: ./frontend
      #   run: |
      #     npm install
      #     npm test
          
  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push images
        run: |
          docker compose -f docker-compose.yml build
          
          # Tag and push each service image
          for service in $(docker compose -f docker-compose.yml config --services); do
            # Use the directory name as the image name prefix to avoid conflicts
            # and ensure it matches the auto-generated image names by compose
            project_name=$(basename $PWD)
            image_name="${project_name}-${service}"
            
            # Check if the image exists locally before tagging and pushing
            if [[ "$(docker images -q ${image_name} 2> /dev/null)" != "" ]]; then
              echo "Tagging and pushing image for $service"
              docker tag ${image_name} ${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest
              docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest
            else
              echo "Skipping push for ${service}, no local image found. It might be a base image like postgres."
            fi
          done

  deploy:
    needs: build-and-push
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        run: echo ${{ secrets.DOCKER_HUB_TOKEN }} | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin

      - name: Deploy services
        run: |
          # This script requires 'yq' (the Go version) to be installed on your server.
          # On Debian/Ubuntu, you can install it with: sudo apt update && sudo apt install yq
          
          # Pull the latest versions of images from Docker Hub
          # We only pull images that are defined with a `build` instruction in docker-compose.yml
          for service in $(docker compose -f docker-compose.yml config --services); do
            project_name="open-labs-share-1"
            image_name="${project_name}-${service}"
            
            # The 'yq' command here checks if a service has a 'build' section.
            if yq e ".services.${service} | has(\"build\")" docker-compose.yml | grep -q "true"; then
              echo "Pulling image for service: $service"
              docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest || echo "Could not pull ${image_name}. It might not be a custom-built image."
            fi
          done

          # Before starting, ensure docker-compose uses the pulled images from Docker Hub.
          # We will modify the docker-compose file in place.
          for service in $(docker compose -f docker-compose.yml config --services); do
            project_name="open-labs-share-1"
            image_name="${project_name}-${service}"
            hub_image="${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest"
            
            if yq e ".services.${service} | has(\"build\")" docker-compose.yml | grep -q "true"; then
                yq e ".services.${service}.image = \"${hub_image}\"" -i docker-compose.yml
            fi
          done
          
          # Restart the services with the new images
          docker compose -f docker-compose.yml up -d
          
          # Clean up old, dangling images
          docker image prune -f