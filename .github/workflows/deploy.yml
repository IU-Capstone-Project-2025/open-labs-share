name: Deploy to Production

on:
  push:
    branches:
      - "*" # TODO: Change to main after testing

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push images
        run: |
          docker-compose -f docker-compose.yml build
          
          # Tag and push each service image
          for service in $(docker-compose -f docker-compose.yml config --services); do
            # Use the directory name as the image name prefix to avoid conflicts
            # and ensure it matches the auto-generated image names by compose
            project_name=$(basename $PWD)
            image_name="${project_name}-${service}"
            
            # Check if the image exists locally before tagging and pushing
            if [[ "$(docker images -q ${image_name} 2> /dev/null)" != "" ]]; then
              echo "Tagging and pushing image for $service"
              docker tag ${image_name} ${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest
              docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest
            else
              echo "Skipping push for ${service}, no local image found. It might be a base image like postgres."
            fi
          done

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.REG_RU_HOST }}
          username: ${{ secrets.REG_RU_USERNAME }}
          key: ${{ secrets.REG_RU_SSH_KEY }}
          script: |
            # Navigate to the project directory
            cd ~/open-labs-share-1
            
            # Log in to Docker Hub
            echo ${{ secrets.DOCKER_HUB_TOKEN }} | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin
            
            # Pull the latest versions of the images from Docker Hub
            # This requires your docker-compose.yml to reference the Docker Hub images
            # e.g., image: yourdockerhubusername/open-labs-share-1-frontend:latest
            # Since it's not set up that way, we will pull each image manually
            for service in $(docker-compose -f docker-compose.yml config --services); do
              project_name="open-labs-share-1"
              image_name="${project_name}-${service}"
              # Check if the image is one that is built from source
              if grep -q "build:" docker-compose.yml; then
                  # This is a simplistic check. A better way would be to inspect the docker-compose config
                  # For now, we assume if a build context exists, we should try to pull it.
                  echo "Pulling image for service: $service"
                  docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest || echo "Could not pull ${image_name}. It might not be a custom-built image."
              fi
            done

            # Update the image references in the docker-compose file before starting
            # This is a critical step. We will use sed to update the image tags.
            # This assumes services that are built have a `build:` section and will be given an `image:` tag.
            for service in $(docker-compose -f docker-compose.yml config --services); do
              project_name="open-labs-share-1"
              image_name="${project_name}-${service}"
              hub_image="${{ secrets.DOCKER_HUB_USERNAME }}/${image_name}:latest"
              # Use yq to be safer than sed
              if command -v yq &> /dev/null && yq ".services.${service} | .build" docker-compose.yml | grep -q "."; then
                  yq e ".services.${service}.image = \"${hub_image}\"" -i docker-compose.yml
              fi
            done
            
            # Start the services
            docker-compose -f docker-compose.yml up -d
            
            # Clean up dangling images
            docker image prune -f